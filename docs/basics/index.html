<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="generator" content="Docusaurus v2.0.0-alpha.58">
<title data-react-helmet="true">Basics Tutorial | ZIO gRPC</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:title" content="Basics Tutorial | ZIO gRPC"><meta data-react-helmet="true" name="description" content="A basic tutorial introduction to gRPC in Java."><meta data-react-helmet="true" property="og:description" content="A basic tutorial introduction to gRPC in Java."><meta data-react-helmet="true" property="og:url" content="https://scalapb.github.io/zio-grpc//zio-grpc/docs/basics"><link data-react-helmet="true" rel="shortcut icon" href="/zio-grpc/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://scalapb.github.io/zio-grpc//zio-grpc/docs/basics"><link rel="stylesheet" href="/zio-grpc/styles.7761ed77.css">
<link rel="preload" href="/zio-grpc/styles.09064728.js" as="script">
<link rel="preload" href="/zio-grpc/runtime~main.cc945210.js" as="script">
<link rel="preload" href="/zio-grpc/main.5707a2ab.js" as="script">
<link rel="preload" href="/zio-grpc/common.9b142690.js" as="script">
<link rel="preload" href="/zio-grpc/2.e6230fac.js" as="script">
<link rel="preload" href="/zio-grpc/30.3b455bfe.js" as="script">
<link rel="preload" href="/zio-grpc/31.147dc868.js" as="script">
<link rel="preload" href="/zio-grpc/a2f44fec.4156f5db.js" as="script">
<link rel="preload" href="/zio-grpc/17896441.64074167.js" as="script">
<link rel="preload" href="/zio-grpc/cdb862af.6da3ea17.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=window.matchMedia("(prefers-color-scheme: dark)"),n=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();null!==n?t(n):e.matches&&t("dark")}()</script><div id="__docusaurus">
<nav class="navbar navbar--light navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/zio-grpc/"><img class="navbar__logo" src="/zio-grpc/img/logo.svg" alt="My Site Logo"><strong class="navbar__title">ZIO gRPC</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/zio-grpc/docs/">Docs</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/scalapb/zio-grpc" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_1gtM"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_keGJ moon_1gwN"></span></div><div class="react-toggle-track-x"><span class="toggle_keGJ sun_3CPA"></span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/zio-grpc/"><img class="navbar__logo" src="/zio-grpc/img/logo.svg" alt="My Site Logo"><strong class="navbar__title">ZIO gRPC</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/zio-grpc/docs/">Docs</a></li><li class="menu__list-item"><a href="https://github.com/scalapb/zio-grpc" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_1kjD"><div class="docSidebarContainer_1cYp" role="complementary"><div class="sidebar_1kLs"><div class="menu menu--responsive menu_w2sC"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_2vk4" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Getting Started</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/zio-grpc/docs/">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/zio-grpc/docs/quickstart">Quick Start</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/zio-grpc/docs/basics">Basics Tutorial</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/zio-grpc/docs/installation">Installing</a></li></ul></li></ul></div></div></div><main class="docMainContainer_FFX1"><div class="container padding-vert--lg docItemWrapper_1cc7"><div class="row"><div class="col docItemCol_2GOA"><div class="docItemContainer_2cwg"><article><header><h1 class="docTitle_1vWb">Basics Tutorial</h1></header><div class="markdown"><p>This tutorial provides a basic introduction to Scala programmers to working with ZIO gRPC.</p><p>By walking through this example you&#x27;ll learn how to:</p><ul><li>Define a service in a .proto file.</li><li>Generate server and client code using ZIO gRPC code generator.</li><li>Use ZIO gRPC API to write a simple client and server for your service.</li></ul><p>It assumes that you have read the <a href="https://grpc.io/docs/what-is-grpc/introduction/" target="_blank" rel="noopener noreferrer">Introduction to
gRPC</a> and are familiar with
<a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener noreferrer">protocol buffers</a>. Note
that the example in this tutorial uses the
<a href="https://github.com/google/protobuf/releases" target="_blank" rel="noopener noreferrer">proto3</a> version of the protocol
buffers language: you can find out more in the <a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="noopener noreferrer">proto3 language
guide</a> and <a href="https://developers.google.com/protocol-buffers/docs/reference/java-generated" target="_blank" rel="noopener noreferrer">Java
generated code
guide</a>.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="why-use-grpc"></a>Why use gRPC?<a aria-hidden="true" tabindex="-1" class="hash-link" href="#why-use-grpc" title="Direct link to heading">#</a></h2><p>Our example is a simple route mapping application that lets clients get information about features on their route, create a summary of their route, and exchange route information such as traffic updates with the server and other clients.</p><p>With gRPC we can define our service once in a <code>.proto</code> file and generate clients and servers in any of gRPC’s supported languages, which in turn can be run in environments ranging from servers inside a large data center to your own tablet — all the complexity of communication between different languages and environments is handled for you by gRPC. We also get all the advantages of working with protocol buffers, including efficient serialization, a simple IDL, and easy interface updating.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="example-code-and-setup"></a>Example code and setup<a aria-hidden="true" tabindex="-1" class="hash-link" href="#example-code-and-setup" title="Direct link to heading">#</a></h2><p>The example code for our tutorial is in
<a href="https://github.com/scalapb/zio-grpc/tree/master/examples/src/main/scala/zio_grpc/examples/routeguide" target="_blank" rel="noopener noreferrer">scalapb/zio-grpc/examples/src/main/scala/zio_grpc/examples/routeguide</a>.
To download the example, clone the latest release in <code>zio-grpc</code> repository by
running the following command:</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockContent_32p_"><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button><div tabindex="0" class="prism-code language-bash codeBlock_19pQ"><div class="codeBlockLines_2n9r" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">$ </span><span class="token function" style="color:rgb(80, 250, 123)">git</span><span class="token plain"> clone -b v0.4.0-RC1 https://github.com/scalapb/zio-grpc.git</span></div></div></div></div></div><p>Then change your current directory to <code>zio-grpc/examples</code>:</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockContent_32p_"><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button><div tabindex="0" class="prism-code language-bash codeBlock_19pQ"><div class="codeBlockLines_2n9r" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">$ </span><span class="token builtin class-name" style="color:rgb(189, 147, 249)">cd</span><span class="token plain"> zio-grpc/examples</span></div></div></div></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="defining-the-service"></a>Defining the service<a aria-hidden="true" tabindex="-1" class="hash-link" href="#defining-the-service" title="Direct link to heading">#</a></h2><p>Our first step (as you&#x27;ll know from the <a href="https://grpc.io/docs/what-is-grpc/introduction/" target="_blank" rel="noopener noreferrer">Introduction to gRPC</a>) is to
define the gRPC <em>service</em> and the method <em>request</em> and <em>response</em> types using
<a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener noreferrer">protocol buffers</a>. You can see the complete .proto file in
<a href="https://github.com/scalapb/zio-grpc/blob/master/examples/src/main/protobuf/route_guide.proto">scalapb/zio-grpc/examples/src/main/protobuf/route_guide.proto</a>.</p><p>ZIO gRPC generates code into the same Scala package that ScalaPB uses. Since <code>java_package</code> is
specified, the Scala package will be the <code>java_package</code> with the proto file name appended to it. In
this case, the package name would be <code>io.grpc.examples.routeguide.route_guide</code>.</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockContent_32p_"><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button><div tabindex="0" class="prism-code language-protobuf codeBlock_19pQ"><div class="codeBlockLines_2n9r" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">option java_package = &quot;io.grpc.examples.routeguide&quot;;</span></div></div></div></div></div><p>You can read more on how ScalaPB determines the Scala package name and how can this be customized
in <a href="https://scalapb.github.io/generated-code.html#default-package-structure">ScalaPB&#x27;s documentation</a>.</p><p>To define a service, we specify a named <code>service</code> in the .proto file:</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockContent_32p_"><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button><div tabindex="0" class="prism-code language-protobuf codeBlock_19pQ"><div class="codeBlockLines_2n9r" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">service RouteGuide {</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">   ...</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></div></div></div></div></div><p>Then we define <code>rpc</code> methods inside our service definition, specifying their
request and response types. gRPC lets you define four kinds of service methods,
all of which are used in the <code>RouteGuide</code> service:</p><ul><li><p>A <em>simple RPC</em> where the client sends a request to the server and waits for a response to come back.</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockContent_32p_"><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button><div tabindex="0" class="prism-code language-protobuf codeBlock_19pQ"><div class="codeBlockLines_2n9r" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">// Obtains the feature at a given position.</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">rpc GetFeature(Point) returns (Feature) {}</span></div></div></div></div></div></li><li><p>A <em>server-side streaming RPC</em> where the client sends a request to the server
and gets a stream to read a sequence of messages back. The client reads from
the returned stream until there are no more messages. As you can see in our
example, you specify a server-side streaming method by placing the <code>stream</code>
keyword before the <em>response</em> type.</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockContent_32p_"><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button><div tabindex="0" class="prism-code language-protobuf codeBlock_19pQ"><div class="codeBlockLines_2n9r" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">// Obtains the Features available within the given Rectangle.  Results are</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">// streamed rather than returned at once (e.g. in a response message with a</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">// repeated field), as the rectangle may cover a large area and contain a</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">// huge number of features.</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">rpc ListFeatures(Rectangle) returns (stream Feature) {}</span></div></div></div></div></div></li><li><p>A <em>client-side streaming RPC</em> where the client sends a stream of messages
to the server. Once the client has finished writing the messages,
it waits for the server to read them all and return its response.
You specify a client-side streaming method by placing the <code>stream</code> keyword
before the <em>request</em> type.</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockContent_32p_"><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button><div tabindex="0" class="prism-code language-protobuf codeBlock_19pQ"><div class="codeBlockLines_2n9r" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">// Accepts a stream of Points on a route being traversed, returning a</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">// RouteSummary when traversal is completed.</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">rpc RecordRoute(stream Point) returns (RouteSummary) {}</span></div></div></div></div></div></li><li><p>A <em>bidirectional streaming RPC</em> where both sides send a sequence of
messages. The two streams operate independently, so clients and servers can
read and write in whatever order they like: for example, the server could
wait to receive all the client messages before writing its responses, or it
could alternately read a message then write a message, or some other
combination of reads and writes. The order of messages in each stream is
preserved. You specify this type of method by placing the <code>stream</code> keyword
before both the request and the response.</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockContent_32p_"><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button><div tabindex="0" class="prism-code language-protobuf codeBlock_19pQ"><div class="codeBlockLines_2n9r" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">// Accepts a stream of RouteNotes sent while a route is being traversed,</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">// while receiving other RouteNotes (e.g. from other users).</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}</span></div></div></div></div></div></li></ul><p>Our <code>.proto</code> file also contains protocol buffer message type definitions for all
the request and response types used in our service methods - for example, here&#x27;s
the <code>Point</code> message type:</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockContent_32p_"><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button><div tabindex="0" class="prism-code language-protobuf codeBlock_19pQ"><div class="codeBlockLines_2n9r" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">// Points are represented as latitude-longitude pairs in the E7 representation</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">// (degrees multiplied by 10**7 and rounded to the nearest integer).</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">// Latitudes should be in the range +/- 90 degrees and longitude should be in</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">// the range +/- 180 degrees (inclusive).</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">message Point {</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  int32 latitude = 1;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  int32 longitude = 2;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></div></div></div></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="generating-client-and-server-code"></a>Generating client and server code<a aria-hidden="true" tabindex="-1" class="hash-link" href="#generating-client-and-server-code" title="Direct link to heading">#</a></h2><p>When you compile the application in SBT (using <code>compile</code>), an SBT plugin named
<code>sbt-protoc</code> invokes two code generators. The first code generator is ScalaPB
which generates case classes for all messages and some gRPC-related code that
ZIO-gRPC interfaces with. The second generator is ZIO gRPC code generator, which
generates a ZIO interface to your service.</p><p>The following classes are generated from our service definition in <code>target/scala_2.13/src_managed</code>:</p><ul><li><code>Feature.scala</code>, <code>Point.scala</code>, <code>Rectangle.scala</code>, and others which contain all
the protocol buffer code to populate, serialize, and retrieve our request and
response message types.</li><li><code>ZioRouteGuide.scala</code> which contains (along with some other useful code):<ul><li>a base trait for <code>RouteGuide</code> servers to implement,
<code>ZioRouteGuide.ZRouteGuide</code>, with all the methods definitions in the
<code>RouteGuide</code> service.</li><li><code>ZioRouteGuide.RouteGuideClient</code>, contains ZIO accessor methods that clients can
use to talk to a <code>RouteGuide</code> server.</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="creating-the-server"></a>Creating the server<a aria-hidden="true" tabindex="-1" class="hash-link" href="#creating-the-server" title="Direct link to heading">#</a></h2><p>First let&#x27;s look at how we create a <code>RouteGuide</code> server. If you&#x27;re only
interested in creating gRPC clients, you can skip this section and go straight
to <a href="#creating-the-client">Creating the client</a> (though you might find it interesting
anyway!).</p><p>There are two parts to making our <code>RouteGuide</code> service do its job:</p><ul><li>Implementing the trait <code>ZRouteGuide</code> generated from our service definition: returning the
ZIO effects that do the actual &quot;work&quot; of our service.</li><li>Putting an instance of ZRouteGuide behind a gRPC server to listen for requests from
clients and return the service responses.</li></ul><p>You can find our example <code>RouteGuide</code> server in
<a href="https://github.com/scalapb/zio-grpc/blob/master/examples/src/main/scala/zio_grpc/examples/routeguide/RouteGuideServer.scala">scalapb/zio-grpc/examples/src/main/scala/zio_grpc/examples/routeguide/RouteGuideServer.scala</a>.
Let&#x27;s take a closer look at how it works.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="implementing-zrouteguide"></a>Implementing ZRouteGuide<a aria-hidden="true" tabindex="-1" class="hash-link" href="#implementing-zrouteguide" title="Direct link to heading">#</a></h3><p>As you can see, our server has a <code>RouteGuideService</code> class that extends the
generated <code>ZioRouteGuide.ZRouteGuide</code> base trait:</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockContent_32p_"><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button><div tabindex="0" class="prism-code language-scala codeBlock_19pQ"><div class="codeBlockLines_2n9r" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">class RouteGuideService(</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    features: Seq[Feature],</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    routeNotesRef: Ref[Map[Point, List[RouteNote]]]</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">) extends ZioRouteGuide.ZRouteGuide[ZEnv, Any] {</span></div></div></div></div></div><p>The trait <code>ZRouteGuide[R, Context]</code> takes two type parameters:</p><ul><li><code>R</code> represents the environment. These can be dependencies that the server needs in order to do its job. In our example <code>R</code> is <code>ZEnv</code> which is ZIO&#x27;s default environment which contains basic services such as <code>Clock</code> and <code>Console</code>.</li><li><code>Context</code> represents data that is unique to each request, for example, Metadata headers, or the identity of the user making the request. We will learn about <code>Context</code> in a future example.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="simple-rpc"></a>Simple RPC<a aria-hidden="true" tabindex="-1" class="hash-link" href="#simple-rpc" title="Direct link to heading">#</a></h3><p><code>RouteGuideService</code> implements all our service methods. Let&#x27;s
look at the simplest method first, <code>GetFeature()</code>, which just gets a <code>Point</code> from
the client and returns the corresponding feature information from its database
in a <code>Feature</code>.</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockContent_32p_"><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button><div tabindex="0" class="prism-code language-scala codeBlock_19pQ"><div class="codeBlockLines_2n9r" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">def getFeature(request: Point): ZIO[ZEnv, Status, Feature] =</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  ZIO.fromOption(findFeature(request)).mapError(_ =&gt; Status.NOT_FOUND)</span></div></div></div></div></div><div class="mdxCodeBlock_iHAB"><div class="codeBlockContent_32p_"><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button><div tabindex="0" class="prism-code language-scala codeBlock_19pQ"><div class="codeBlockLines_2n9r" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">def findFeature(point: Point): Option[Feature] =</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  features.find(f =&gt; f.getLocation == point &amp;&amp; f.name.nonEmpty)</span></div></div></div></div></div><p>The <code>getFeature()</code> method takes the request (of type <code>Point</code>), and returns a ZIO
effect that represents the work of computing the response. As in all ZIO effect, the
value that is returned is a suspended effect: nothing actually happens until ZIO runtime
ultimately runs the effect. The type of the effect is <code>ZIO[ZEnv, Status, Feature]</code> which means
it is a computation:</p><ul><li>can fail with value of type <code>Status</code> (this type comes from grpc-java and represents a gRPC status code).</li><li>can succeed with value of type <code>Feature</code>.</li><li>requires an environment of type <code>ZEnv</code> to run.</li></ul><p>In this case, our effect is built on top of a pure function <code>findFeature</code> that returns <code>Some(feature)</code>
if there is a feature in the database that corresponds to the given point, or <code>None</code> otherwise.</p><p>We use <code>ZIO.fromOption</code> to turn the <code>Option[Feature]</code> into an effect of type <code>IO[Option[Nothing], Feature]</code>
which means that it can either succeed with a value of type <code>Feature</code> or fail with a value of type <code>Option[Nothing]</code> (the only possible value of this type is <code>None</code> since there are no instances of type <code>Nothing</code>). We
then use <code>mapError</code> to map the case of an error to gRPC&#x27;s <code>NOT_FOUND</code> status.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="server-side-streaming-rpc"></a>Server-side streaming RPC<a aria-hidden="true" tabindex="-1" class="hash-link" href="#server-side-streaming-rpc" title="Direct link to heading">#</a></h3><p>Next let&#x27;s look at one of our streaming RPCs. <code>ListFeatures</code> is a server-side
streaming RPC, so we need to send back multiple <code>Feature</code>s to our client.</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockContent_32p_"><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button><div tabindex="0" class="prism-code language-scala codeBlock_19pQ"><div class="codeBlockLines_2n9r" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">def listFeatures(request: Rectangle): ZStream[ZEnv, Status, Feature] = {</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  val left = request.getLo.longitude min request.getHi.longitude</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  val right = request.getLo.longitude max request.getHi.longitude</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  val top = request.getLo.latitude max request.getHi.latitude</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  val bottom = request.getLo.latitude min request.getHi.latitude</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  ZStream.fromIterable(</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    features.filter { feature =&gt;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">      val lat = feature.getLocation.latitude</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">      val lon = feature.getLocation.longitude</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">      lon &gt;= left &amp;&amp; lon &lt;= right &amp;&amp; lat &gt;= bottom &amp;&amp; lat &lt;= top</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  )</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></div></div></div></div></div><p>Like the simple RPC, this method gets a request object (the <code>Rectangle</code> in which
our client wants to find <code>Feature</code>s) and returns a <code>ZStream[ZEnv, Status, Feature]</code>, which represents an effectful stream that can produce, provided an environment of type
<code>ZEnv</code> zero or more elements of type <code>Feature</code> and fail with a value of type of <code>Status</code>.</p><p> This time, the stream does not need the environment and can not ever fail (since
our database is a constant in the same process!)</p><p> We build the stream from a Scala collection we build by filtering through the features
sequence. ZIO gRPC takes over streaming the response to the client when the stream
gets executed.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="client-side-streaming-rpc"></a>Client-side streaming RPC<a aria-hidden="true" tabindex="-1" class="hash-link" href="#client-side-streaming-rpc" title="Direct link to heading">#</a></h3><p>Now let&#x27;s look at something a little more complicated: the client-side streaming
method <code>RecordRoute()</code>, where we get a stream of <code>Point</code>s from the client and
return a single <code>RouteSummary</code> with information about their trip once the stream finishes.</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockContent_32p_"><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button><div tabindex="0" class="prism-code language-scala codeBlock_19pQ"><div class="codeBlockLines_2n9r" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">def recordRoute(</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    request: zio.stream.Stream[Status, Point]</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">): ZIO[Clock, Status, RouteSummary] = {</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  // Zips each element with the previous element, initially accompanied by None.</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  request.zipWithPrevious</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    .fold(RouteSummary()) {</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">      case (summary, (maybePrevPoint, currentPoint)) =&gt;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        // Compute the next status based on the current status.</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        summary.copy(</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">          pointCount = summary.pointCount + 1,</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">          featureCount =</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">            summary.featureCount + (if (findFeature(currentPoint).isDefined) 1</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">                                    else 0),</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">          distance = summary.distance + maybePrevPoint</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">            .map(calcDistance(_, currentPoint))</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">            .getOrElse(0)</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        )</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    .timed // returns a new effect that times the execution</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    .map {</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">      case (duration, summary) =&gt;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        summary.copy(elapsedTime = (duration.toMillis / 1000).toInt)</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></div></div></div></div></div><p>Here, our method gets a stream that is produced by the client. As you can see
from the signature of this method, our goal would be to turn this stream into an
effect that results in a <code>RouteSummary</code>.</p><p><code>RouteSummary</code> contains the number of points, number of features on the trip, total distance passed, and the time it took. As this summary can be built iteratively we use fold, which takes the summary and new input to compute the next summary. Since we are
adding up the distance between successive pair of points, we will use <code>zipWithPrevious</code>
that gives us a pair <code>(Option[Point], Point)</code> where the left element represents the previous element in the stream (which is initially None).</p><p>The <code>fold</code> method gives us a <code>IO[Status, RouteSummary]</code>. Using the <code>timed</code> method we are getting a new ZIO effect that upon success gives us the a tuple <code>(zio.duration.Duration, RouteSummary)</code> where the duration represents the time it took to process
the effect thus far. We then use <code>map</code> to turn it back to a <code>RouteSummary</code> that contains the elapsed time in seconds.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="bidirectional-streaming-rpc"></a>Bidirectional streaming RPC<a aria-hidden="true" tabindex="-1" class="hash-link" href="#bidirectional-streaming-rpc" title="Direct link to heading">#</a></h3><p>Finally, let&#x27;s look at our bidirectional streaming RPC <code>RouteChat()</code>.</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockContent_32p_"><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button><div tabindex="0" class="prism-code language-scala codeBlock_19pQ"><div class="codeBlockLines_2n9r" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">def routeChat(</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    request: zio.stream.Stream[Status, RouteNote]</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">): ZStream[ZEnv, Status, RouteNote] =</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  request.flatMap { note =&gt;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    // By using flatMap, we can map each RouteNote we receive to a stream with</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    // the existing RouteNotes for that location, and those sub-streams are going</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    // to get concatenated.</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    // We start from an effect that updates the map with the new RouteNote,</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    // and returns the notes associated with the location just before the update.</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    val updateMapEffect: UIO[List[RouteNote]] =</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">      routeNotesRef.modify { routeNotes =&gt;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        val messages = routeNotes.getOrElse(note.getLocation, Nil)</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        (messages, routeNotes.updated(note.getLocation, note :: messages))</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">      }</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    // We create a stream from the effect.</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    ZStream.fromIterableM(updateMapEffect)</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span></div></div></div></div></div><p>As with our client-side streaming example, we are getting a <code>Stream</code> of
<code>RouteNote</code>s, except this time we are also returning a stream of
<code>RouteNote</code>s. Although each side will always get the other&#x27;s messages in the
order they were written, both the client and server can read and write in any
order — the streams operate completely independently.</p><p>In this example, we are using <code>flatMap</code> on the incoming stream to map each input to a new
effectful stream representing the notes that are available in that location. We are using <code>Ref#modify</code> to mutate the collection of notes in the given location and return the list of notes available just prior to the update.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="starting-the-server"></a>Starting the server<a aria-hidden="true" tabindex="-1" class="hash-link" href="#starting-the-server" title="Direct link to heading">#</a></h2><p>Once we&#x27;ve implemented all our methods, we also need to start up a gRPC server
so that clients can actually use our service. The following snippet shows how we
do this for our <code>RouteGuide</code> service:</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockContent_32p_"><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button><div tabindex="0" class="prism-code language-scala codeBlock_19pQ"><div class="codeBlockLines_2n9r" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">object RouteGuideServer extends ServerMain {</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  override def port: Int = 8980</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  val featuresDatabase = JsonFormat.fromJsonString[FeatureDatabase](</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    Source.fromResource(&quot;route_guide_db.json&quot;).mkString</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  )</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  val createRouteGuide = for {</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    routeNotes &lt;- Ref.make(Map.empty[Point, List[RouteNote]])</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  } yield new RouteGuideService(featuresDatabase.feature, routeNotes)</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  def services: ServiceList[zio.ZEnv] =</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    ServiceList.addM[ZEnv, RouteGuideImpl](createRouteGuide)</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></div></div></div></div></div><p>ZIO gRPC provides a base trait to quickly set up gRPC services with zero boilerplate.</p><ol><li>We override the port we are going to use (default is 9000)</li><li>Create an effect that constructs an instance of our service (we need an effectful construction since
our service constructor takes a <code>zio.Ref</code>)</li><li>Override <code>def services</code> to return a <code>ServiceList</code> that contains our service.</li></ol><p><code>ServerMain</code> is meant to be used for simple applications. If you need to do more in your initialization, you can take a look at the source code of <code>ServerMain</code> and customize.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="creating-the-client"></a>Creating the client<a aria-hidden="true" tabindex="-1" class="hash-link" href="#creating-the-client" title="Direct link to heading">#</a></h2><p>In this section, we&#x27;ll look at creating a client for our <code>RouteGuide</code>
service. You can see our complete example client code in
<a href="https://github.com/scalapb/zio-grpc/blob/master/examples/src/main/scala/zio_grpc/examples/routeguide/RouteGuideClientApp.java">RouteGuideClientApp.java</a>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="instantiating-a-client"></a>Instantiating a client<a aria-hidden="true" tabindex="-1" class="hash-link" href="#instantiating-a-client" title="Direct link to heading">#</a></h3><p>To call service methods, we first need to create a client. There are two patterns
to work with clients:</p><ul><li>Use <code>RouteGuideClient.managed</code> to instantiate a client inside a <code>zio.ZManaged</code>. Then through calling its <code>use</code> method, the client can be accessed and method can be called on it.</li><li>Use <code>RouteGuideClient.live</code> to create a <code>ZLayer</code> that can be used to provide a client as a singleton to our program through the environment. In that case, throughout the program we use accessor methods, defined statically in <code>RouteGuideClient</code> that expect the client to be available in the environment.</li></ul><p>Throughout this tutorial, we will follow the second pattern. We create a <code>Layer</code> that can provide a <code>RouteGuideClient</code> like this:</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockContent_32p_"><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button><div tabindex="0" class="prism-code language-scala codeBlock_19pQ"><div class="codeBlockLines_2n9r" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">val clientLayer: Layer[Throwable, RouteGuideClient] =</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  RouteGuideClient.live(</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    ZManagedChannel(</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">      ManagedChannelBuilder.forAddress(&quot;localhost&quot;, 8980).usePlaintext()</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    )</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  )</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="calling-service-methods"></a>Calling service methods<a aria-hidden="true" tabindex="-1" class="hash-link" href="#calling-service-methods" title="Direct link to heading">#</a></h3><p>Now let&#x27;s look at how we call our service methods.</p><p>As described above, <code>RouteGuideClient</code> contains accessor methods for each RPC
that return an effect or a stream that needs a client in the environment to be ran:</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockContent_32p_"><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button><div tabindex="0" class="prism-code language-scala codeBlock_19pQ"><div class="codeBlockLines_2n9r" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">def getFeature(req: Point):</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  ZIO[RouteGuideClient, Status, Feature]</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">def listFeatures(req: Rectangle):</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  ZStream[RouteGuideClient, Status, Feature]</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">def recordRoute[R0](req: ZStream[R0, Status, Point]):</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  ZIO[RouteGuideClient with R0, Status, RouteSummary]</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">def routeChat[R0](req: ZStream[R0, Status, RouteNote]):</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  ZStream[RouteGuideClient with R0, Status, RouteNote]</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="simple-rpc-1"></a>Simple RPC<a aria-hidden="true" tabindex="-1" class="hash-link" href="#simple-rpc-1" title="Direct link to heading">#</a></h3><p>Calling the simple RPC <code>GetFeature</code> on the static accessor stub is as
straightforward as instantiating a local effect:</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockContent_32p_"><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button><div tabindex="0" class="prism-code language-scala codeBlock_19pQ"><div class="codeBlockLines_2n9r" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">def getFeature(</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    lat: Int,</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    lng: Int</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">): ZIO[RouteGuideClient with Console, Status, Unit] =</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  (for {</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    f &lt;- RouteGuideClient.getFeature(Point(lat, lng))</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    _ &lt;- putStrLn(s&quot;&quot;&quot;Found feature called &quot;${f.name}&quot;.&quot;&quot;&quot;)</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  } yield ()).catchSome {</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    case status if status == Status.NOT_FOUND =&gt;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">      putStrLn(s&quot;Feature not found: ${status.toString()}&quot;)</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span></div></div></div></div></div><p>We create and populate a request protocol buffer object (in our case
<code>Point</code>), pass it to the <code>getFeature()</code> method on our accessor, and get
back an effect that needs a <code>RouteGuideClient</code> environment. We chain
the response with a call to <code>putStrLn</code> to print the result on the console,
and we catch the <code>NOT_FOUND</code> response and print an error. All other errors
are not handled at this level and will &quot;bubble up&quot; up to the program&#x27;s <code>exitCode</code> handler.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="server-side-streaming-rpc-1"></a>Server-side streaming RPC<a aria-hidden="true" tabindex="-1" class="hash-link" href="#server-side-streaming-rpc-1" title="Direct link to heading">#</a></h3><p>Next, let&#x27;s look at a server-side streaming call to <code>ListFeatures</code>, which
returns a stream of geographical <code>Feature</code>s:</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockContent_32p_"><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button><div tabindex="0" class="prism-code language-scala codeBlock_19pQ"><div class="codeBlockLines_2n9r" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">_ &lt;-</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  RouteGuideClient</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    .listFeatures(</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">      Rectangle(</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        lo = Some(Point(400000000, -750000000)),</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        hi = Some(Point(420000000, -730000000))</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">      )</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    )</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    .zipWithIndex</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    .foreach {</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">      case (feature, index) =&gt;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        putStrLn(s&quot;Result #${index + 1}: $feature&quot;)</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></div></div></div></div></div><p>Now <code>listFeatures</code> returns a <code>ZStream</code>. We use <code>zipWithIndex</code> to get a stream
where each of the original elements are accompanied with a zero-based index. We turn
this stream into a single effect that processes the entire streasm by calling <code>foreach</code>
and providing it with a function that maps each element into an effect. In this case,
the effect prints the feature.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="client-side-streaming-rpc-1"></a>Client-side streaming RPC<a aria-hidden="true" tabindex="-1" class="hash-link" href="#client-side-streaming-rpc-1" title="Direct link to heading">#</a></h3><p>Now for something a little more complicated: the client-side streaming method
<code>RecordRoute</code>, where we send a stream of <code>Point</code>s to the server and get back
a single <code>RouteSummary</code>.</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockContent_32p_"><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button><div tabindex="0" class="prism-code language-scala codeBlock_19pQ"><div class="codeBlockLines_2n9r" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">def recordRoute(numPoints: Int) =</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  for {</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    summary &lt;- RouteGuideClient.recordRoute(</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">      ZStream</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        .repeatEffect(</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">          nextIntBetween(0, features.size).map(features(_).getLocation)</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        )</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        .tap(p =&gt; putStrLn(s&quot;Visiting (${p.latitude}, ${p.longitude})&quot;))</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        .schedule(Schedule.randomDelay(200.millis, 500.millis))</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        .take(numPoints)</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    )</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    _ &lt;- putStrLn(</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">      s&quot;Finished trip with ${summary.pointCount} points. &quot; +</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        s&quot;Passed ${summary.featureCount} features. &quot; +</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        s&quot;Travelled ${summary.distance} meters. &quot; +</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        s&quot;It took ${summary.elapsedTime} seconds.&quot;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    )</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  } yield ()</span></div></div></div></div></div><p>Here, we pass into <code>recordRoute</code> an effectful stream that randomly picks an element from the <code>features</code> collection (a constant), and insert random delay between elements.</p><p>Like all the other accessor methods it&#x27;s worth noting that no side effect happens upon calling  <code>recordRoute</code>. The method returns immediately giving us an effect that represents sending this stream to the server. When the effect ultimately run it can succeed with a value of type <code>RouteSummary</code> once the entire stream has been sent to the server.</p><p>In this example, we chain to this effect an effect to print the summary to the console.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="bidirectional-streaming-rpc-1"></a>Bidirectional streaming RPC<a aria-hidden="true" tabindex="-1" class="hash-link" href="#bidirectional-streaming-rpc-1" title="Direct link to heading">#</a></h3><p>Finally, let&#x27;s look at our bidirectional streaming RPC <code>RouteChat()</code>.</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockContent_32p_"><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button><div tabindex="0" class="prism-code language-scala codeBlock_19pQ"><div class="codeBlockLines_2n9r" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">val routeChat =</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  for {</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    res &lt;-</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">      RouteGuideClient</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        .routeChat(</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">          ZStream(</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">            RouteNote(</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">              location = Some(Point(0, 0)),</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">              message = &quot;First message&quot;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">            ),</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">            RouteNote(</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">              location = Some(Point(0, 10_000_000)),</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">              message = &quot;Second Message&quot;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">            ),</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">            RouteNote(</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">              location = Some(Point(10_000_000, 0)),</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">              message = &quot;Third Message&quot;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">            ),</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">            RouteNote(</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">              location = Some(Point(10_000_000, 10_000_000)),</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">              message = &quot;Four Message&quot;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">            )</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">          ).tap { note =&gt;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">            putStrLn(</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">              s&quot;&quot;&quot;Sending message &quot;${note.message}&quot; at ${note.getLocation.latitude}, ${note.getLocation.longitude}&quot;&quot;&quot;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">            )</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">          }</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        )</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        .foreach { note =&gt;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">          putStrLn(</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">            s&quot;&quot;&quot;Got message &quot;${note.message}&quot; at ${note.getLocation.latitude}, ${note.getLocation.longitude}&quot;&quot;&quot;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">          )</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  } yield ()</span></div></div></div></div></div><p>In this method, we both get and return a <code>Stream</code> of
RouteNotes. Here both streams execute independently at the same time. Although each side will always
get the other&#x27;s messages in the order they were written, both the client and
server can read and write in any order — the streams operate completely
independently.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="providing-the-client-layer-into-the-application-logic"></a>Providing the client layer into the application logic<a aria-hidden="true" tabindex="-1" class="hash-link" href="#providing-the-client-layer-into-the-application-logic" title="Direct link to heading">#</a></h3><p>All the effects we created were dependent on a <code>RouteGuideClient</code> available in the environment. We earlier instantiated a <code>clientLayer</code>, so we can provide it to our application logic at the top-level (the <code>run</code> method):</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockContent_32p_"><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button><div tabindex="0" class="prism-code language-scala codeBlock_19pQ"><div class="codeBlockLines_2n9r" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">val myAppLogic =</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  for {</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    // Looking for a valid feature</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    _ &lt;- getFeature(409146138, -746188906)</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    // Looking for a missing feature</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    _ &lt;- getFeature(0, 0)</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    // Calls listFeatures with a rectangle of interest. Prints</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    // each response feature as it arrives.</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    // start: listFeatures</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    _ &lt;-</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">      RouteGuideClient</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        .listFeatures(</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">          Rectangle(</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">            lo = Some(Point(400000000, -750000000)),</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">            hi = Some(Point(420000000, -730000000))</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">          )</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        )</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        .zipWithIndex</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        .foreach {</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">          case (feature, index) =&gt;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">            putStrLn(s&quot;Result #${index + 1}: $feature&quot;)</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    // end: listFeatures</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    _ &lt;- recordRoute(10)</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    _ &lt;- routeChat</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  } yield ()</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">final def run(args: List[String]) =</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">  myAppLogic.provideCustomLayer(clientLayer).exitCode</span></div></div></div></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="try-it-out"></a>Try it out!<a aria-hidden="true" tabindex="-1" class="hash-link" href="#try-it-out" title="Direct link to heading">#</a></h2><ol><li><p>Run the server:</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockContent_32p_"><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button><div tabindex="0" class="prism-code language-bash codeBlock_19pQ"><div class="codeBlockLines_2n9r" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">sbt </span><span class="token string" style="color:rgb(255, 121, 198)">&quot;runMain zio_grpc.examples.routeguide.RouteGuideServer&quot;</span></div></div></div></div></div></li><li><p>From another terminal, run the client:</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockContent_32p_"><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button><div tabindex="0" class="prism-code language-bash codeBlock_19pQ"><div class="codeBlockLines_2n9r" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">sbt </span><span class="token string" style="color:rgb(255, 121, 198)">&quot;runMain zio_grpc.examples.routeguide.RouteGuideClientApp&quot;</span></div></div></div></div></div></li></ol></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/scalapb/zio-grpc/edit/master/foo/docs/../zio-grpc-docs/target/mdoc/basics.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 40 40" style="margin-right:0.3em;vertical-align:sub"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/zio-grpc/docs/quickstart"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« Quick Start</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/zio-grpc/docs/installation"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Installing ZIO gRPC »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_TbNY"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#why-use-grpc" class="table-of-contents__link">Why use gRPC?</a></li><li><a href="#example-code-and-setup" class="table-of-contents__link">Example code and setup</a></li><li><a href="#defining-the-service" class="table-of-contents__link">Defining the service</a></li><li><a href="#generating-client-and-server-code" class="table-of-contents__link">Generating client and server code</a></li><li><a href="#creating-the-server" class="table-of-contents__link">Creating the server</a><ul><li><a href="#implementing-zrouteguide" class="table-of-contents__link">Implementing ZRouteGuide</a></li><li><a href="#simple-rpc" class="table-of-contents__link">Simple RPC</a></li><li><a href="#server-side-streaming-rpc" class="table-of-contents__link">Server-side streaming RPC</a></li><li><a href="#client-side-streaming-rpc" class="table-of-contents__link">Client-side streaming RPC</a></li><li><a href="#bidirectional-streaming-rpc" class="table-of-contents__link">Bidirectional streaming RPC</a></li></ul></li><li><a href="#starting-the-server" class="table-of-contents__link">Starting the server</a></li><li><a href="#creating-the-client" class="table-of-contents__link">Creating the client</a><ul><li><a href="#instantiating-a-client" class="table-of-contents__link">Instantiating a client</a></li><li><a href="#calling-service-methods" class="table-of-contents__link">Calling service methods</a></li><li><a href="#simple-rpc-1" class="table-of-contents__link">Simple RPC</a></li><li><a href="#server-side-streaming-rpc-1" class="table-of-contents__link">Server-side streaming RPC</a></li><li><a href="#client-side-streaming-rpc-1" class="table-of-contents__link">Client-side streaming RPC</a></li><li><a href="#bidirectional-streaming-rpc-1" class="table-of-contents__link">Bidirectional streaming RPC</a></li><li><a href="#providing-the-client-layer-into-the-application-logic" class="table-of-contents__link">Providing the client layer into the application logic</a></li></ul></li><li><a href="#try-it-out" class="table-of-contents__link">Try it out!</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/zio-grpc/docs/">Introduction</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/scalapb" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow</a></li><li class="footer__item"><a href="https://gitter.im/ScalaPB/community" target="_blank" rel="noopener noreferrer" class="footer__link-item">Gitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a href="https://github.com/scalapb/zio-grpc" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="text--center"><div>Copyright © 2020 Nadav Samet</div></div></div></footer></div>
<script src="/zio-grpc/styles.09064728.js"></script>
<script src="/zio-grpc/runtime~main.cc945210.js"></script>
<script src="/zio-grpc/main.5707a2ab.js"></script>
<script src="/zio-grpc/common.9b142690.js"></script>
<script src="/zio-grpc/2.e6230fac.js"></script>
<script src="/zio-grpc/30.3b455bfe.js"></script>
<script src="/zio-grpc/31.147dc868.js"></script>
<script src="/zio-grpc/a2f44fec.4156f5db.js"></script>
<script src="/zio-grpc/17896441.64074167.js"></script>
<script src="/zio-grpc/cdb862af.6da3ea17.js"></script>
</body>
</html>