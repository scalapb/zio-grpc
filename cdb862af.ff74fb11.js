(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{159:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return u}));var a=n(2),i=n(9),r=(n(0),n(170)),o={title:"Basics Tutorial",description:"A basic tutorial introduction to gRPC in Java."},s={id:"basics",isDocsHomePage:!1,title:"Basics Tutorial",description:"A basic tutorial introduction to gRPC in Java.",source:"@site/../zio-grpc-docs/target/mdoc/basics.md",permalink:"/zio-grpc/docs/basics",editUrl:"https://github.com/scalapb/zio-grpc/edit/master/foo/docs/../zio-grpc-docs/target/mdoc/basics.md",sidebar:"someSidebar",previous:{title:"Quick Start",permalink:"/zio-grpc/docs/quickstart"},next:{title:"Installing ZIO gRPC",permalink:"/zio-grpc/docs/installation"}},c=[{value:"Why use gRPC?",id:"why-use-grpc",children:[]},{value:"Example code and setup",id:"example-code-and-setup",children:[]},{value:"Defining the service",id:"defining-the-service",children:[]},{value:"Generating client and server code",id:"generating-client-and-server-code",children:[]},{value:"Creating the server",id:"creating-the-server",children:[{value:"Implementing ZRouteGuide",id:"implementing-zrouteguide",children:[]},{value:"Simple RPC",id:"simple-rpc",children:[]},{value:"Server-side streaming RPC",id:"server-side-streaming-rpc",children:[]},{value:"Client-side streaming RPC",id:"client-side-streaming-rpc",children:[]},{value:"Bidirectional streaming RPC",id:"bidirectional-streaming-rpc",children:[]}]},{value:"Starting the server",id:"starting-the-server",children:[]},{value:"Creating the client",id:"creating-the-client",children:[{value:"Instantiating a client",id:"instantiating-a-client",children:[]},{value:"Calling service methods",id:"calling-service-methods",children:[]},{value:"Simple RPC",id:"simple-rpc-1",children:[]},{value:"Server-side streaming RPC",id:"server-side-streaming-rpc-1",children:[]},{value:"Client-side streaming RPC",id:"client-side-streaming-rpc-1",children:[]},{value:"Bidirectional streaming RPC",id:"bidirectional-streaming-rpc-1",children:[]},{value:"Providing the client layer into the application logic",id:"providing-the-client-layer-into-the-application-logic",children:[]}]},{value:"Try it out!",id:"try-it-out",children:[]}],l={rightToc:c};function u(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"This tutorial provides a basic introduction to Scala programmers to working with ZIO gRPC."),Object(r.b)("p",null,"By walking through this example you'll learn how to:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Define a service in a .proto file."),Object(r.b)("li",{parentName:"ul"},"Generate server and client code using ZIO gRPC code generator."),Object(r.b)("li",{parentName:"ul"},"Use ZIO gRPC API to write a simple client and server for your service.")),Object(r.b)("p",null,"It assumes that you have read the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://grpc.io/docs/what-is-grpc/introduction/"}),"Introduction to\ngRPC")," and are familiar with\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://developers.google.com/protocol-buffers/docs/overview"}),"protocol buffers"),". Note\nthat the example in this tutorial uses the\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/google/protobuf/releases"}),"proto3")," version of the protocol\nbuffers language: you can find out more in the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://developers.google.com/protocol-buffers/docs/proto3"}),"proto3 language\nguide")," and ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://developers.google.com/protocol-buffers/docs/reference/java-generated"}),"Java\ngenerated code\nguide"),"."),Object(r.b)("h2",{id:"why-use-grpc"},"Why use gRPC?"),Object(r.b)("p",null,"Our example is a simple route mapping application that lets clients get information about features on their route, create a summary of their route, and exchange route information such as traffic updates with the server and other clients."),Object(r.b)("p",null,"With gRPC we can define our service once in a ",Object(r.b)("inlineCode",{parentName:"p"},".proto")," file and generate clients and servers in any of gRPC\u2019s supported languages, which in turn can be run in environments ranging from servers inside a large data center to your own tablet \u2014 all the complexity of communication between different languages and environments is handled for you by gRPC. We also get all the advantages of working with protocol buffers, including efficient serialization, a simple IDL, and easy interface updating."),Object(r.b)("h2",{id:"example-code-and-setup"},"Example code and setup"),Object(r.b)("p",null,"The example code for our tutorial is in\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/scalapb/zio-grpc/tree/master/examples/src/main/scala/zio_grpc/examples/routeguide"}),"scalapb/zio-grpc/examples/src/main/scala/zio_grpc/examples/routeguide"),".\nTo download the example, clone the latest release in ",Object(r.b)("inlineCode",{parentName:"p"},"zio-grpc")," repository by\nrunning the following command:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"$ git clone -b v0.4.0-RC1 https://github.com/scalapb/zio-grpc.git\n")),Object(r.b)("p",null,"Then change your current directory to ",Object(r.b)("inlineCode",{parentName:"p"},"zio-grpc/examples"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"$ cd zio-grpc/examples\n")),Object(r.b)("h2",{id:"defining-the-service"},"Defining the service"),Object(r.b)("p",null,"Our first step (as you'll know from the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://grpc.io/docs/what-is-grpc/introduction/"}),"Introduction to gRPC"),") is to\ndefine the gRPC ",Object(r.b)("em",{parentName:"p"},"service")," and the method ",Object(r.b)("em",{parentName:"p"},"request")," and ",Object(r.b)("em",{parentName:"p"},"response")," types using\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://developers.google.com/protocol-buffers/docs/overview"}),"protocol buffers"),". You can see the complete .proto file in\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/scalapb/zio-grpc/blob/master/examples/src/main/protobuf/route_guide.proto"}),"scalapb/zio-grpc/examples/src/main/protobuf/route_guide.proto"),"."),Object(r.b)("p",null,"ZIO gRPC generates code into the same Scala package that ScalaPB uses. Since ",Object(r.b)("inlineCode",{parentName:"p"},"java_package")," is\nspecified, the Scala package will be the ",Object(r.b)("inlineCode",{parentName:"p"},"java_package")," with the proto file name appended to it. In\nthis case, the package name would be ",Object(r.b)("inlineCode",{parentName:"p"},"io.grpc.examples.routeguide.route_guide"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-protobuf"}),'option java_package = "io.grpc.examples.routeguide";\n')),Object(r.b)("p",null,"You can read more on how ScalaPB determines the Scala package name and how can this be customized\nin ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://scalapb.github.io/generated-code.html#default-package-structure"}),"ScalaPB's documentation"),"."),Object(r.b)("p",null,"To define a service, we specify a named ",Object(r.b)("inlineCode",{parentName:"p"},"service")," in the .proto file:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-protobuf"}),"service RouteGuide {\n   ...\n}\n")),Object(r.b)("p",null,"Then we define ",Object(r.b)("inlineCode",{parentName:"p"},"rpc")," methods inside our service definition, specifying their\nrequest and response types. gRPC lets you define four kinds of service methods,\nall of which are used in the ",Object(r.b)("inlineCode",{parentName:"p"},"RouteGuide")," service:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"A ",Object(r.b)("em",{parentName:"p"},"simple RPC")," where the client sends a request to the server and waits for a response to come back."),Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-protobuf"}),"// Obtains the feature at a given position.\nrpc GetFeature(Point) returns (Feature) {}\n"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"A ",Object(r.b)("em",{parentName:"p"},"server-side streaming RPC")," where the client sends a request to the server\nand gets a stream to read a sequence of messages back. The client reads from\nthe returned stream until there are no more messages. As you can see in our\nexample, you specify a server-side streaming method by placing the ",Object(r.b)("inlineCode",{parentName:"p"},"stream"),"\nkeyword before the ",Object(r.b)("em",{parentName:"p"},"response")," type."),Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-protobuf"}),"// Obtains the Features available within the given Rectangle.  Results are\n// streamed rather than returned at once (e.g. in a response message with a\n// repeated field), as the rectangle may cover a large area and contain a\n// huge number of features.\nrpc ListFeatures(Rectangle) returns (stream Feature) {}\n"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"A ",Object(r.b)("em",{parentName:"p"},"client-side streaming RPC")," where the client sends a stream of messages\nto the server. Once the client has finished writing the messages,\nit waits for the server to read them all and return its response.\nYou specify a client-side streaming method by placing the ",Object(r.b)("inlineCode",{parentName:"p"},"stream")," keyword\nbefore the ",Object(r.b)("em",{parentName:"p"},"request")," type."),Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-protobuf"}),"// Accepts a stream of Points on a route being traversed, returning a\n// RouteSummary when traversal is completed.\nrpc RecordRoute(stream Point) returns (RouteSummary) {}\n"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"A ",Object(r.b)("em",{parentName:"p"},"bidirectional streaming RPC")," where both sides send a sequence of\nmessages. The two streams operate independently, so clients and servers can\nread and write in whatever order they like: for example, the server could\nwait to receive all the client messages before writing its responses, or it\ncould alternately read a message then write a message, or some other\ncombination of reads and writes. The order of messages in each stream is\npreserved. You specify this type of method by placing the ",Object(r.b)("inlineCode",{parentName:"p"},"stream")," keyword\nbefore both the request and the response."),Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-protobuf"}),"// Accepts a stream of RouteNotes sent while a route is being traversed,\n// while receiving other RouteNotes (e.g. from other users).\nrpc RouteChat(stream RouteNote) returns (stream RouteNote) {}\n")))),Object(r.b)("p",null,"Our ",Object(r.b)("inlineCode",{parentName:"p"},".proto")," file also contains protocol buffer message type definitions for all\nthe request and response types used in our service methods - for example, here's\nthe ",Object(r.b)("inlineCode",{parentName:"p"},"Point")," message type:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-protobuf"}),"// Points are represented as latitude-longitude pairs in the E7 representation\n// (degrees multiplied by 10**7 and rounded to the nearest integer).\n// Latitudes should be in the range +/- 90 degrees and longitude should be in\n// the range +/- 180 degrees (inclusive).\nmessage Point {\n  int32 latitude = 1;\n  int32 longitude = 2;\n}\n")),Object(r.b)("h2",{id:"generating-client-and-server-code"},"Generating client and server code"),Object(r.b)("p",null,"When you compile the application in SBT (using ",Object(r.b)("inlineCode",{parentName:"p"},"compile"),"), an SBT plugin named\n",Object(r.b)("inlineCode",{parentName:"p"},"sbt-protoc")," invokes two code generators. The first code generator is ScalaPB\nwhich generates case classes for all messages and some gRPC-related code that\nZIO-gRPC interfaces with. The second generator is ZIO gRPC code generator, which\ngenerates a ZIO interface to your service."),Object(r.b)("p",null,"The following classes are generated from our service definition in ",Object(r.b)("inlineCode",{parentName:"p"},"target/scala_2.13/src_managed"),":"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Feature.scala"),", ",Object(r.b)("inlineCode",{parentName:"li"},"Point.scala"),", ",Object(r.b)("inlineCode",{parentName:"li"},"Rectangle.scala"),", and others which contain all\nthe protocol buffer code to populate, serialize, and retrieve our request and\nresponse message types."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"ZioRouteGuide.scala")," which contains (along with some other useful code):",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"a base trait for ",Object(r.b)("inlineCode",{parentName:"li"},"RouteGuide")," servers to implement,\n",Object(r.b)("inlineCode",{parentName:"li"},"ZioRouteGuide.ZRouteGuide"),", with all the methods definitions in the\n",Object(r.b)("inlineCode",{parentName:"li"},"RouteGuide")," service."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"ZioRouteGuide.RouteGuideClient"),", contains ZIO accessor methods that clients can\nuse to talk to a ",Object(r.b)("inlineCode",{parentName:"li"},"RouteGuide")," server.")))),Object(r.b)("h2",{id:"creating-the-server"},"Creating the server"),Object(r.b)("p",null,"First let's look at how we create a ",Object(r.b)("inlineCode",{parentName:"p"},"RouteGuide")," server. If you're only\ninterested in creating gRPC clients, you can skip this section and go straight\nto ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#creating-the-client"}),"Creating the client")," (though you might find it interesting\nanyway!)."),Object(r.b)("p",null,"There are two parts to making our ",Object(r.b)("inlineCode",{parentName:"p"},"RouteGuide")," service do its job:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Implementing the trait ",Object(r.b)("inlineCode",{parentName:"li"},"ZRouteGuide"),' generated from our service definition: returning the\nZIO effects that do the actual "work" of our service.'),Object(r.b)("li",{parentName:"ul"},"Putting an instance of ZRouteGuide behind a gRPC server to listen for requests from\nclients and return the service responses.")),Object(r.b)("p",null,"You can find our example ",Object(r.b)("inlineCode",{parentName:"p"},"RouteGuide")," server in\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/scalapb/zio-grpc/blob/master/examples/src/main/scala/zio_grpc/examples/routeguide/RouteGuideServer.scala"}),"scalapb/zio-grpc/examples/src/main/scala/zio_grpc/examples/routeguide/RouteGuideServer.scala"),".\nLet's take a closer look at how it works."),Object(r.b)("h3",{id:"implementing-zrouteguide"},"Implementing ZRouteGuide"),Object(r.b)("p",null,"As you can see, our server has a ",Object(r.b)("inlineCode",{parentName:"p"},"RouteGuideService")," class that extends the\ngenerated ",Object(r.b)("inlineCode",{parentName:"p"},"ZioRouteGuide.ZRouteGuide")," base trait:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"class RouteGuideService(\n    features: Seq[Feature],\n    routeNotesRef: Ref[Map[Point, List[RouteNote]]]\n) extends ZioRouteGuide.ZRouteGuide[ZEnv, Any] {\n")),Object(r.b)("p",null,"The trait ",Object(r.b)("inlineCode",{parentName:"p"},"ZRouteGuide[R, Context]")," takes two type parameters:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"R")," represents the environment. These can be dependencies that the server needs in order to do its job. In our example ",Object(r.b)("inlineCode",{parentName:"li"},"R")," is ",Object(r.b)("inlineCode",{parentName:"li"},"ZEnv")," which is ZIO's default environment which contains basic services such as ",Object(r.b)("inlineCode",{parentName:"li"},"Clock")," and ",Object(r.b)("inlineCode",{parentName:"li"},"Console"),"."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Context")," represents data that is unique to each request, for example, Metadata headers, or the identity of the user making the request. We will learn about ",Object(r.b)("inlineCode",{parentName:"li"},"Context")," in a future example.")),Object(r.b)("h3",{id:"simple-rpc"},"Simple RPC"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"RouteGuideService")," implements all our service methods. Let's\nlook at the simplest method first, ",Object(r.b)("inlineCode",{parentName:"p"},"GetFeature()"),", which just gets a ",Object(r.b)("inlineCode",{parentName:"p"},"Point")," from\nthe client and returns the corresponding feature information from its database\nin a ",Object(r.b)("inlineCode",{parentName:"p"},"Feature"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"def getFeature(request: Point): ZIO[ZEnv, Status, Feature] =\n  ZIO.fromOption(findFeature(request)).mapError(_ => Status.NOT_FOUND)\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"def findFeature(point: Point): Option[Feature] =\n  features.find(f => f.getLocation == point && f.name.nonEmpty)\n")),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"getFeature()")," method takes the request (of type ",Object(r.b)("inlineCode",{parentName:"p"},"Point"),"), and returns a ZIO\neffect that represents the work of computing the response. As in all ZIO effect, the\nvalue that is returned is a suspended effect: nothing actually happens until ZIO runtime\nultimately runs the effect. The type of the effect is ",Object(r.b)("inlineCode",{parentName:"p"},"ZIO[ZEnv, Status, Feature]")," which means\nit is a computation:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"can fail with value of type ",Object(r.b)("inlineCode",{parentName:"li"},"Status")," (this type comes from grpc-java and represents a gRPC status code)."),Object(r.b)("li",{parentName:"ul"},"can succeed with value of type ",Object(r.b)("inlineCode",{parentName:"li"},"Feature"),"."),Object(r.b)("li",{parentName:"ul"},"requires an environment of type ",Object(r.b)("inlineCode",{parentName:"li"},"ZEnv")," to run.")),Object(r.b)("p",null,"In this case, our effect is built on top of a pure function ",Object(r.b)("inlineCode",{parentName:"p"},"findFeature")," that returns ",Object(r.b)("inlineCode",{parentName:"p"},"Some(feature)"),"\nif there is a feature in the database that corresponds to the given point, or ",Object(r.b)("inlineCode",{parentName:"p"},"None")," otherwise."),Object(r.b)("p",null,"We use ",Object(r.b)("inlineCode",{parentName:"p"},"ZIO.fromOption")," to turn the ",Object(r.b)("inlineCode",{parentName:"p"},"Option[Feature]")," into an effect of type ",Object(r.b)("inlineCode",{parentName:"p"},"IO[Option[Nothing], Feature]"),"\nwhich means that it can either succeed with a value of type ",Object(r.b)("inlineCode",{parentName:"p"},"Feature")," or fail with a value of type ",Object(r.b)("inlineCode",{parentName:"p"},"Option[Nothing]")," (the only possible value of this type is ",Object(r.b)("inlineCode",{parentName:"p"},"None")," since there are no instances of type ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing"),"). We\nthen use ",Object(r.b)("inlineCode",{parentName:"p"},"mapError")," to map the case of an error to gRPC's ",Object(r.b)("inlineCode",{parentName:"p"},"NOT_FOUND")," status."),Object(r.b)("h3",{id:"server-side-streaming-rpc"},"Server-side streaming RPC"),Object(r.b)("p",null,"Next let's look at one of our streaming RPCs. ",Object(r.b)("inlineCode",{parentName:"p"},"ListFeatures")," is a server-side\nstreaming RPC, so we need to send back multiple ",Object(r.b)("inlineCode",{parentName:"p"},"Feature"),"s to our client."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"def listFeatures(request: Rectangle): ZStream[ZEnv, Status, Feature] = {\n  val left = request.getLo.longitude min request.getHi.longitude\n  val right = request.getLo.longitude max request.getHi.longitude\n  val top = request.getLo.latitude max request.getHi.latitude\n  val bottom = request.getLo.latitude min request.getHi.latitude\n\n  ZStream.fromIterable(\n    features.filter { feature =>\n      val lat = feature.getLocation.latitude\n      val lon = feature.getLocation.longitude\n      lon >= left && lon <= right && lat >= bottom && lat <= top\n    }\n  )\n}\n")),Object(r.b)("p",null,"Like the simple RPC, this method gets a request object (the ",Object(r.b)("inlineCode",{parentName:"p"},"Rectangle")," in which\nour client wants to find ",Object(r.b)("inlineCode",{parentName:"p"},"Feature"),"s) and returns a ",Object(r.b)("inlineCode",{parentName:"p"},"ZStream[ZEnv, Status, Feature]"),", which represents an effectful stream that can produce, provided an environment of type\n",Object(r.b)("inlineCode",{parentName:"p"},"ZEnv")," zero or more elements of type ",Object(r.b)("inlineCode",{parentName:"p"},"Feature")," and fail with a value of type of ",Object(r.b)("inlineCode",{parentName:"p"},"Status"),"."),Object(r.b)("p",null," This time, the stream does not need the environment and can not ever fail (since\nour database is a constant in the same process!)"),Object(r.b)("p",null," We build the stream from a Scala collection we build by filtering through the features\nsequence. ZIO gRPC takes over streaming the response to the client when the stream\ngets executed."),Object(r.b)("h3",{id:"client-side-streaming-rpc"},"Client-side streaming RPC"),Object(r.b)("p",null,"Now let's look at something a little more complicated: the client-side streaming\nmethod ",Object(r.b)("inlineCode",{parentName:"p"},"RecordRoute()"),", where we get a stream of ",Object(r.b)("inlineCode",{parentName:"p"},"Point"),"s from the client and\nreturn a single ",Object(r.b)("inlineCode",{parentName:"p"},"RouteSummary")," with information about their trip once the stream finishes."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"def recordRoute(\n    request: zio.stream.Stream[Status, Point]\n): ZIO[Clock, Status, RouteSummary] = {\n  // Zips each element with the previous element, initially accompanied by None.\n  request.zipWithPrevious\n    .fold(RouteSummary()) {\n      case (summary, (maybePrevPoint, currentPoint)) =>\n        // Compute the next status based on the current status.\n        summary.copy(\n          pointCount = summary.pointCount + 1,\n          featureCount =\n            summary.featureCount + (if (findFeature(currentPoint).isDefined) 1\n                                    else 0),\n          distance = summary.distance + maybePrevPoint\n            .map(calcDistance(_, currentPoint))\n            .getOrElse(0)\n        )\n    }\n    .timed // returns a new effect that times the execution\n    .map {\n      case (duration, summary) =>\n        summary.copy(elapsedTime = (duration.toMillis / 1000).toInt)\n    }\n}\n")),Object(r.b)("p",null,"Here, our method gets a stream that is produced by the client. As you can see\nfrom the signature of this method, our goal would be to turn this stream into an\neffect that results in a ",Object(r.b)("inlineCode",{parentName:"p"},"RouteSummary"),"."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"RouteSummary")," contains the number of points, number of features on the trip, total distance passed, and the time it took. As this summary can be built iteratively we use fold, which takes the summary and new input to compute the next summary. Since we are\nadding up the distance between successive pair of points, we will use ",Object(r.b)("inlineCode",{parentName:"p"},"zipWithPrevious"),"\nthat gives us a pair ",Object(r.b)("inlineCode",{parentName:"p"},"(Option[Point], Point)")," where the left element represents the previous element in the stream (which is initially None)."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"fold")," method gives us a ",Object(r.b)("inlineCode",{parentName:"p"},"IO[Status, RouteSummary]"),". Using the ",Object(r.b)("inlineCode",{parentName:"p"},"timed")," method we are getting a new ZIO effect that upon success gives us the a tuple ",Object(r.b)("inlineCode",{parentName:"p"},"(zio.duration.Duration, RouteSummary)")," where the duration represents the time it took to process\nthe effect thus far. We then use ",Object(r.b)("inlineCode",{parentName:"p"},"map")," to turn it back to a ",Object(r.b)("inlineCode",{parentName:"p"},"RouteSummary")," that contains the elapsed time in seconds."),Object(r.b)("h3",{id:"bidirectional-streaming-rpc"},"Bidirectional streaming RPC"),Object(r.b)("p",null,"Finally, let's look at our bidirectional streaming RPC ",Object(r.b)("inlineCode",{parentName:"p"},"RouteChat()"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"def routeChat(\n    request: zio.stream.Stream[Status, RouteNote]\n): ZStream[ZEnv, Status, RouteNote] =\n  request.flatMap { note =>\n    // By using flatMap, we can map each RouteNote we receive to a stream with\n    // the existing RouteNotes for that location, and those sub-streams are going\n    // to get concatenated.\n    // We start from an effect that updates the map with the new RouteNote,\n    // and returns the notes associated with the location just before the update.\n    val updateMapEffect: UIO[List[RouteNote]] =\n      routeNotesRef.modify { routeNotes =>\n        val messages = routeNotes.getOrElse(note.getLocation, Nil)\n        (messages, routeNotes.updated(note.getLocation, note :: messages))\n      }\n    // We create a stream from the effect.\n    ZStream.fromIterableM(updateMapEffect)\n  }\n")),Object(r.b)("p",null,"As with our client-side streaming example, we are getting a ",Object(r.b)("inlineCode",{parentName:"p"},"Stream")," of\n",Object(r.b)("inlineCode",{parentName:"p"},"RouteNote"),"s, except this time we are also returning a stream of\n",Object(r.b)("inlineCode",{parentName:"p"},"RouteNote"),"s. Although each side will always get the other's messages in the\norder they were written, both the client and server can read and write in any\norder \u2014 the streams operate completely independently."),Object(r.b)("p",null,"In this example, we are using ",Object(r.b)("inlineCode",{parentName:"p"},"flatMap")," on the incoming stream to map each input to a new\neffectful stream representing the notes that are available in that location. We are using ",Object(r.b)("inlineCode",{parentName:"p"},"Ref#modify")," to mutate the collection of notes in the given location and return the list of notes available just prior to the update."),Object(r.b)("h2",{id:"starting-the-server"},"Starting the server"),Object(r.b)("p",null,"Once we've implemented all our methods, we also need to start up a gRPC server\nso that clients can actually use our service. The following snippet shows how we\ndo this for our ",Object(r.b)("inlineCode",{parentName:"p"},"RouteGuide")," service:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),'object RouteGuideServer extends ServerMain {\n  override def port: Int = 8980\n\n  val featuresDatabase = JsonFormat.fromJsonString[FeatureDatabase](\n    Source.fromResource("route_guide_db.json").mkString\n  )\n\n  val createRouteGuide = for {\n    routeNotes <- Ref.make(Map.empty[Point, List[RouteNote]])\n  } yield new RouteGuideService(featuresDatabase.feature, routeNotes)\n\n  def services: ServiceList[zio.ZEnv] =\n    ServiceList.addM[ZEnv, RouteGuideService](createRouteGuide)\n}\n')),Object(r.b)("p",null,"ZIO gRPC provides a base trait to quickly set up gRPC services with zero boilerplate."),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"We override the port we are going to use (default is 9000)"),Object(r.b)("li",{parentName:"ol"},"Create an effect that constructs an instance of our service (we need an effectful construction since\nour service constructor takes a ",Object(r.b)("inlineCode",{parentName:"li"},"zio.Ref"),")"),Object(r.b)("li",{parentName:"ol"},"Override ",Object(r.b)("inlineCode",{parentName:"li"},"def services")," to return a ",Object(r.b)("inlineCode",{parentName:"li"},"ServiceList")," that contains our service.")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"ServerMain")," is meant to be used for simple applications. If you need to do more in your initialization, you can take a look at the source code of ",Object(r.b)("inlineCode",{parentName:"p"},"ServerMain")," and customize."),Object(r.b)("h2",{id:"creating-the-client"},"Creating the client"),Object(r.b)("p",null,"In this section, we'll look at creating a client for our ",Object(r.b)("inlineCode",{parentName:"p"},"RouteGuide"),"\nservice. You can see our complete example client code in\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/scalapb/zio-grpc/blob/master/examples/src/main/scala/zio_grpc/examples/routeguide/RouteGuideClientApp.java"}),"RouteGuideClientApp.java"),"."),Object(r.b)("h3",{id:"instantiating-a-client"},"Instantiating a client"),Object(r.b)("p",null,"To call service methods, we first need to create a client. There are two patterns\nto work with clients:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Use ",Object(r.b)("inlineCode",{parentName:"li"},"RouteGuideClient.managed")," to instantiate a client inside a ",Object(r.b)("inlineCode",{parentName:"li"},"zio.ZManaged"),". Then through calling its ",Object(r.b)("inlineCode",{parentName:"li"},"use")," method, the client can be accessed and method can be called on it."),Object(r.b)("li",{parentName:"ul"},"Use ",Object(r.b)("inlineCode",{parentName:"li"},"RouteGuideClient.live")," to create a ",Object(r.b)("inlineCode",{parentName:"li"},"ZLayer")," that can be used to provide a client as a singleton to our program through the environment. In that case, throughout the program we use accessor methods, defined statically in ",Object(r.b)("inlineCode",{parentName:"li"},"RouteGuideClient")," that expect the client to be available in the environment.")),Object(r.b)("p",null,"Throughout this tutorial, we will follow the second pattern. We create a ",Object(r.b)("inlineCode",{parentName:"p"},"Layer")," that can provide a ",Object(r.b)("inlineCode",{parentName:"p"},"RouteGuideClient")," like this:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),'val clientLayer: Layer[Throwable, RouteGuideClient] =\n  RouteGuideClient.live(\n    ZManagedChannel(\n      ManagedChannelBuilder.forAddress("localhost", 8980).usePlaintext()\n    )\n  )\n')),Object(r.b)("h3",{id:"calling-service-methods"},"Calling service methods"),Object(r.b)("p",null,"Now let's look at how we call our service methods."),Object(r.b)("p",null,"As described above, ",Object(r.b)("inlineCode",{parentName:"p"},"RouteGuideClient")," contains accessor methods for each RPC\nthat return an effect or a stream that needs a client in the environment to be ran:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"def getFeature(req: Point):\n  ZIO[RouteGuideClient, Status, Feature]\n\ndef listFeatures(req: Rectangle):\n  ZStream[RouteGuideClient, Status, Feature]\n\ndef recordRoute[R0](req: ZStream[R0, Status, Point]):\n  ZIO[RouteGuideClient with R0, Status, RouteSummary]\n\ndef routeChat[R0](req: ZStream[R0, Status, RouteNote]):\n  ZStream[RouteGuideClient with R0, Status, RouteNote]\n")),Object(r.b)("h3",{id:"simple-rpc-1"},"Simple RPC"),Object(r.b)("p",null,"Calling the simple RPC ",Object(r.b)("inlineCode",{parentName:"p"},"GetFeature")," on the static accessor stub is as\nstraightforward as instantiating a local effect:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),'def getFeature(\n    lat: Int,\n    lng: Int\n): ZIO[RouteGuideClient with Console, Status, Unit] =\n  (for {\n    f <- RouteGuideClient.getFeature(Point(lat, lng))\n    _ <- putStrLn(s"""Found feature called "${f.name}".""")\n  } yield ()).catchSome {\n    case status if status == Status.NOT_FOUND =>\n      putStrLn(s"Feature not found: ${status.toString()}")\n  }\n')),Object(r.b)("p",null,"We create and populate a request protocol buffer object (in our case\n",Object(r.b)("inlineCode",{parentName:"p"},"Point"),"), pass it to the ",Object(r.b)("inlineCode",{parentName:"p"},"getFeature()")," method on our accessor, and get\nback an effect that needs a ",Object(r.b)("inlineCode",{parentName:"p"},"RouteGuideClient")," environment. We chain\nthe response with a call to ",Object(r.b)("inlineCode",{parentName:"p"},"putStrLn")," to print the result on the console,\nand we catch the ",Object(r.b)("inlineCode",{parentName:"p"},"NOT_FOUND"),' response and print an error. All other errors\nare not handled at this level and will "bubble up" up to the program\'s ',Object(r.b)("inlineCode",{parentName:"p"},"exitCode")," handler."),Object(r.b)("h3",{id:"server-side-streaming-rpc-1"},"Server-side streaming RPC"),Object(r.b)("p",null,"Next, let's look at a server-side streaming call to ",Object(r.b)("inlineCode",{parentName:"p"},"ListFeatures"),", which\nreturns a stream of geographical ",Object(r.b)("inlineCode",{parentName:"p"},"Feature"),"s:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),'_ <-\n  RouteGuideClient\n    .listFeatures(\n      Rectangle(\n        lo = Some(Point(400000000, -750000000)),\n        hi = Some(Point(420000000, -730000000))\n      )\n    )\n    .zipWithIndex\n    .foreach {\n      case (feature, index) =>\n        putStrLn(s"Result #${index + 1}: $feature")\n    }\n')),Object(r.b)("p",null,"Now ",Object(r.b)("inlineCode",{parentName:"p"},"listFeatures")," returns a ",Object(r.b)("inlineCode",{parentName:"p"},"ZStream"),". We use ",Object(r.b)("inlineCode",{parentName:"p"},"zipWithIndex")," to get a stream\nwhere each of the original elements are accompanied with a zero-based index. We turn\nthis stream into a single effect that processes the entire streasm by calling ",Object(r.b)("inlineCode",{parentName:"p"},"foreach"),"\nand providing it with a function that maps each element into an effect. In this case,\nthe effect prints the feature."),Object(r.b)("h3",{id:"client-side-streaming-rpc-1"},"Client-side streaming RPC"),Object(r.b)("p",null,"Now for something a little more complicated: the client-side streaming method\n",Object(r.b)("inlineCode",{parentName:"p"},"RecordRoute"),", where we send a stream of ",Object(r.b)("inlineCode",{parentName:"p"},"Point"),"s to the server and get back\na single ",Object(r.b)("inlineCode",{parentName:"p"},"RouteSummary"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),'def recordRoute(numPoints: Int) =\n  for {\n    summary <- RouteGuideClient.recordRoute(\n      ZStream\n        .repeatEffect(\n          nextIntBetween(0, features.size).map(features(_).getLocation)\n        )\n        .tap(p => putStrLn(s"Visiting (${p.latitude}, ${p.longitude})"))\n        .schedule(Schedule.randomDelay(200.millis, 500.millis))\n        .take(numPoints)\n    )\n    _ <- putStrLn(\n      s"Finished trip with ${summary.pointCount} points. " +\n        s"Passed ${summary.featureCount} features. " +\n        s"Travelled ${summary.distance} meters. " +\n        s"It took ${summary.elapsedTime} seconds."\n    )\n  } yield ()\n')),Object(r.b)("p",null,"Here, we pass into ",Object(r.b)("inlineCode",{parentName:"p"},"recordRoute")," an effectful stream that randomly picks an element from the ",Object(r.b)("inlineCode",{parentName:"p"},"features")," collection (a constant), and insert random delay between elements."),Object(r.b)("p",null,"Like all the other accessor methods it's worth noting that no side effect happens upon calling  ",Object(r.b)("inlineCode",{parentName:"p"},"recordRoute"),". The method returns immediately giving us an effect that represents sending this stream to the server. When the effect ultimately run it can succeed with a value of type ",Object(r.b)("inlineCode",{parentName:"p"},"RouteSummary")," once the entire stream has been sent to the server."),Object(r.b)("p",null,"In this example, we chain to this effect an effect to print the summary to the console."),Object(r.b)("h3",{id:"bidirectional-streaming-rpc-1"},"Bidirectional streaming RPC"),Object(r.b)("p",null,"Finally, let's look at our bidirectional streaming RPC ",Object(r.b)("inlineCode",{parentName:"p"},"RouteChat()"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),'val routeChat =\n  for {\n    res <-\n      RouteGuideClient\n        .routeChat(\n          ZStream(\n            RouteNote(\n              location = Some(Point(0, 0)),\n              message = "First message"\n            ),\n            RouteNote(\n              location = Some(Point(0, 10_000_000)),\n              message = "Second Message"\n            ),\n            RouteNote(\n              location = Some(Point(10_000_000, 0)),\n              message = "Third Message"\n            ),\n            RouteNote(\n              location = Some(Point(10_000_000, 10_000_000)),\n              message = "Four Message"\n            )\n          ).tap { note =>\n            putStrLn(\n              s"""Sending message "${note.message}" at ${note.getLocation.latitude}, ${note.getLocation.longitude}"""\n            )\n          }\n        )\n        .foreach { note =>\n          putStrLn(\n            s"""Got message "${note.message}" at ${note.getLocation.latitude}, ${note.getLocation.longitude}"""\n          )\n        }\n  } yield ()\n')),Object(r.b)("p",null,"In this method, we both get and return a ",Object(r.b)("inlineCode",{parentName:"p"},"Stream")," of\nRouteNotes. Here both streams execute independently at the same time. Although each side will always\nget the other's messages in the order they were written, both the client and\nserver can read and write in any order \u2014 the streams operate completely\nindependently."),Object(r.b)("h3",{id:"providing-the-client-layer-into-the-application-logic"},"Providing the client layer into the application logic"),Object(r.b)("p",null,"All the effects we created were dependent on a ",Object(r.b)("inlineCode",{parentName:"p"},"RouteGuideClient")," available in the environment. We earlier instantiated a ",Object(r.b)("inlineCode",{parentName:"p"},"clientLayer"),", so we can provide it to our application logic at the top-level (the ",Object(r.b)("inlineCode",{parentName:"p"},"run")," method):"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),'val myAppLogic =\n  for {\n    // Looking for a valid feature\n    _ <- getFeature(409146138, -746188906)\n    // Looking for a missing feature\n    _ <- getFeature(0, 0)\n\n    // Calls listFeatures with a rectangle of interest. Prints\n    // each response feature as it arrives.\n    // start: listFeatures\n    _ <-\n      RouteGuideClient\n        .listFeatures(\n          Rectangle(\n            lo = Some(Point(400000000, -750000000)),\n            hi = Some(Point(420000000, -730000000))\n          )\n        )\n        .zipWithIndex\n        .foreach {\n          case (feature, index) =>\n            putStrLn(s"Result #${index + 1}: $feature")\n        }\n    // end: listFeatures\n\n    _ <- recordRoute(10)\n\n    _ <- routeChat\n  } yield ()\n\nfinal def run(args: List[String]) =\n  myAppLogic.provideCustomLayer(clientLayer).exitCode\n')),Object(r.b)("h2",{id:"try-it-out"},"Try it out!"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Run the server:"),Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),'sbt "runMain zio_grpc.examples.routeguide.RouteGuideServer"\n'))),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"From another terminal, run the client:"),Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),'sbt "runMain zio_grpc.examples.routeguide.RouteGuideClientApp"\n')))),Object(r.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(r.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},'This document, "ZIO gRPC: Basics Tutorial", is a derivative of ',Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://grpc.io/docs/languages/java/basics/"}),'"gRPC ',"\u2013",' Basics Tutorial"')," by ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://grpc.io/"}),"gRPC Authors"),", used under ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://creativecommons.org/licenses/by/4.0"}),"CC-BY-4.0"),'. "ZIO gRPC: Basics Tutorial" is licensed under ',Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://creativecommons.org/licenses/by/4.0"}),"CC-BY-4.0")," by Nadav Samet."))))}u.isMDXComponent=!0}}]);